catalog = {}
borrowed_books = {}
catalog = {}
borrowed_books = {}
"""
Library service module containing core library management functions.
"""
import pytest
from unittest.mock import patch
import services.library_service as ls
from datetime import datetime, timedelta

# 全局变量存储数据（简单实现）
catalog = {}
patrons = {}
borrowed_books = {}
catalog_id_counter = 0

# ==================== Database Helper Functions ====================

def get_catalog():
    """Get the catalog storage."""
    return catalog

def get_borrowed_books():
    """Get the borrowed books storage."""
    return borrowed_books

def get_patron_borrowed_books(patron_id):
    """Get all books borrowed by a patron."""
    patron_books = []
    for borrow_key, record in borrowed_books.items():
        if record["patron_id"] == patron_id and not record.get("returned", False):
            patron_books.append(record)
    return patron_books

# ==================== Catalog Management ====================

def add_book_to_catalog(title, author, isbn, total_copies=1):
    global catalog
    global catalog
    """
    Add a book to the catalog.
    
    Returns:
        tuple: (success: bool, message: str)
    """
    global catalog_id_counter
    
    # Validation
    if not title or title.strip() == "":
        return (False, "Title is required.")
    
    if len(title) > 200:
        return (False, "Title too long.")
    
    if not author or author.strip() == "":
        return (False, "Author is required.")
    
    if len(author) > 100:
        return (False, "Author too long.")
    
    if isbn and len(isbn) not in [10, 13]:
        return (False, "ISBN must be 10 or 13 characters.")
    
    if not isinstance(total_copies, int) or total_copies < 1:
        return (False, "Total copies must be a positive integer.")
    
    # Check for duplicate ISBN using get_book_by_isbn
    if isbn:
        existing_book = get_book_by_isbn(isbn)
        if existing_book:
            return (False, "Book with this ISBN already exists.")
    
    # Add book
    catalog_id_counter += 1
    book_id = catalog_id_counter
    
    catalog[book_id] = {
        "book_id": book_id,
        "title": title.strip(),
        "author": author.strip(),
        "isbn": isbn if isbn else "",
        "total_copies": total_copies,
        "available_copies": total_copies
    }
    
    return (True, "Book added successfully.")


def get_book_by_id(book_id):
    """Get book details by ID."""
    return catalog.get(book_id)


def get_all_books():
    """Get all books in catalog."""
    return list(catalog.values())


# ==================== Borrowing Management ====================

def borrow_book_by_patron(patron_id, book_id):
    global borrowed_books, catalog
    """
    Borrow a book for a patron.
    
    Returns:
        tuple: (success: bool, message: str)
    """
    # Validation
    if not patron_id:
        return (False, "Patron ID is required.")
    
    if not isinstance(patron_id, str) or not patron_id.isdigit():
        return (False, "Patron ID must be numeric.")
    
    if len(patron_id) != 6:
        return (False, "Patron ID must be 6 digits.")
    
    # Try to get book from catalog
    book = catalog.get(book_id)
    
    # If not in catalog, try get_book_by_id (may be mocked in tests)
    if not book:
        book = get_book_by_id(book_id)
    
    # If still not found
    if not book:
        return (False, "Book not found.")
    
    # Check availability
    available = book.get("available_copies", 0)
    if available <= 0:
        return (False, "Book not available.")
    
    # Check if already borrowed
    borrow_key = f"{patron_id}_{book_id}"
    if borrow_key in borrowed_books and not borrowed_books[borrow_key].get("returned", False):
        return (False, "Book already borrowed by this patron.")
    
    # Create borrowing record
    borrow_record = {
        "patron_id": patron_id,
        "book_id": book_id,
        "borrow_date": datetime.now(),
        "due_date": datetime.now() + timedelta(days=14),
        "returned": False
    }
    
    # Try to insert - may be mocked in tests
    insert_result = insert_borrow_record(borrow_record)
    
    # If insert_borrow_record is mocked and returns False, it's a DB error
    if insert_result is False:
        return (False, "Database error: Failed to create borrow record.")
    
    # Also add to borrowed_books dict
    borrowed_books[borrow_key] = borrow_record
    
    book["available_copies"] -= 1
    
    return (True, "Book borrowed successfully.")

    """
    Borrow a book for a patron.
    
    Returns:
        tuple: (success: bool, message: str)
    """
    # Validation
    if not patron_id:
        return (False, "Patron ID is required.")
    
    if not isinstance(patron_id, str) or not patron_id.isdigit():
        return (False, "Patron ID must be numeric.")
    
    if len(patron_id) != 6:
        return (False, "Patron ID must be 6 digits.")
    
    book = catalog.get(book_id)
    if not book:
        return (False, "Book not found.")
    
    # Handle both "available_copies" key names
    available = book.get("available_copies", 0)
    if available <= 0:
        return (False, "Book not available.")
    
    # Check if already borrowed
    borrow_key = f"{patron_id}_{book_id}"
    if borrow_key in borrowed_books and not borrowed_books[borrow_key].get("returned", False):
        return (False, "Book already borrowed by this patron.")
    
    # Create borrowing record
    borrow_record = {
        "patron_id": patron_id,
        "book_id": book_id,
        "borrow_date": datetime.now(),
        "due_date": datetime.now() + timedelta(days=14),
        "returned": False
    }
    
    # Try to insert - may be mocked in tests
    insert_result = insert_borrow_record(borrow_record)
    
    # If insert_borrow_record is mocked and returns False, it's a DB error
    if insert_result is False:
        return (False, "Database error: Failed to create borrow record.")
    
    # Also add to borrowed_books dict
    borrowed_books[borrow_key] = borrow_record
    
    book["available_copies"] -= 1
    
    return (True, "Book borrowed successfully.")


def return_book_by_patron(patron_id, book_id):
    """
    Return a borrowed book.
    
    Returns:
        tuple: (success: bool, message: str, late_fee: float)
    """
    # Try to find the borrow record
    borrow_key = f"{patron_id}_{book_id}"
    borrow_record = borrowed_books.get(borrow_key)
    
    # If not found in global dict, check if it exists via get_patron_borrowed_books (for mocking)
    if not borrow_record:
        patron_books = get_patron_borrowed_books(patron_id)
        for pb in patron_books:
            if pb.get("book_id") == book_id and not pb.get("returned", False):
                borrow_record = pb
                # Add it to borrowed_books for consistency
                borrowed_books[borrow_key] = pb
                break
    
    if not borrow_record:
        return (False, "Book not borrowed by this patron.")
    
    if borrow_record.get("returned", False):
        return (False, "Book already returned.")
    
    # Calculate late fee
    late_fee_data = calculate_late_fee_for_book(patron_id, book_id)
    # Handle both dict and float return types
    if isinstance(late_fee_data, dict):
        late_fee = late_fee_data.get("fee_amount", 0.0)
    else:
        late_fee = late_fee_data if late_fee_data else 0.0
    
    # Mark as returned
    borrow_record["returned"] = True
    borrow_record["return_date"] = datetime.now()
    
    # Increase available copies
    book = catalog.get(book_id)
    if book:
        book["available_copies"] += 1
    
    if late_fee > 0:
        return (True, late_fee, f"Book returned with late fee of ${late_fee:.2f}.")
    else:
        return (True, 0.0, "Book returned successfully.")


# ==================== Late Fee Management ====================

def calculate_late_fee_for_book(patron_id, book_id):
    """
    Calculate late fee for a borrowed book.
    
    Returns:
        dict: {"fee_amount": float} or float (depending on context)
    """
    borrow_key = f"{patron_id}_{book_id}"
    borrow_record = borrowed_books.get(borrow_key)
    
    # Check if there's any borrow record for this patron/book
    if not borrow_record:
        # Also check via get_patron_borrowed_books (for mocked tests)
        patron_books = get_patron_borrowed_books(patron_id)
        for pb in patron_books:
            if pb.get("book_id") == book_id:
                borrow_record = pb
                break
    
    if not borrow_record:
        return {"fee_amount": 0.0, "status": "No active borrow record found"}
    
    if borrow_record.get("returned", False):
        return {"fee_amount": 0.0, "status": "success"}
    
    due_date = borrow_record.get("due_date")
    
    # Handle both datetime objects and string dates (from mocks)
    if isinstance(due_date, str):
        from datetime import datetime as dt
        due_date = dt.fromisoformat(due_date.replace('Z', '+00:00'))
    elif not due_date:
        return {"fee_amount": 0.0, "status": "success"}
    
    now = datetime.now()
    
    # Make both timezone-naive for comparison
    if hasattr(due_date, 'tzinfo') and due_date.tzinfo:
        due_date = due_date.replace(tzinfo=None)
    
    if now <= due_date:
        return {"fee_amount": 0.0, "status": "success"}
    
    # Calculate days overdue
    days_overdue = (now - due_date).days
    
    # $0.50 per day late fee
    late_fee = days_overdue * 0.50
    
    # Cap at $15
    fee_amount = min(late_fee, 15.0)
    return {"fee_amount": fee_amount, "status": "success"}


def pay_late_fees(patron_id, book_id, payment_gateway):
    """
    Process payment for late fees.
    
    Returns:
        tuple: (success: bool, message: str)
    """
    # Validate patron_id - must be a string of digits
    if not patron_id or not isinstance(patron_id, str) or not patron_id.isdigit():
        return (False, "Invalid patron ID.")
    
    try:
        late_fee_data = calculate_late_fee_for_book(patron_id, book_id)
        late_fee = late_fee_data.get("fee_amount", 0.0)
        
        if late_fee == 0:
            return (True, "No late fee to pay.")
        
        book = get_book_by_id(book_id)
        if not book:
            return (False, "Book not found.")
        
        # Process payment with patron_id and amount as keyword arguments
        payment_result = payment_gateway.process_payment(patron_id=patron_id, amount=late_fee)
        
        if payment_result.get("status") == "success":
            return (True, f"Payment of ${late_fee:.2f} processed successfully.")
        else:
            return (False, "Payment declined.")
        
    except Exception as e:
        return (False, f"Network error: {str(e)}")


def refund_late_fee_payment(transaction_id, amount, payment_gateway):
    """
    Process refund for late fee payment.
    
    Returns:
        tuple: (success: bool, message: str)
    """
    if not transaction_id or not isinstance(transaction_id, str) or transaction_id.strip() == "":
        return (False, "Invalid transaction ID.")
    
    if not isinstance(amount, (int, float)) or amount <= 0 or amount > 15:
        return (False, "Invalid amount.")
    
    try:
        refund_result = payment_gateway.refund_payment(transaction_id, amount)
        
        if refund_result.get("status") == "success":
            return (True, f"Refund of ${amount:.2f} processed successfully.")
        else:
            # Return the exact reason from the gateway
            reason = refund_result.get("reason")
            if reason:
                return (False, reason)
            else:
                return (False, "Refund failed")
    except Exception as e:
        return (False, f"Refund error: {str(e)}")


# ==================== Search Management ====================

def search_books_in_catalog(query=None, author=None, title=None, isbn=None):
    """
    Search for books in the catalog.
    
    Returns:
        list: List of matching books
    """
    results = []
    
    for book in catalog.values():
        match = True
        
        if query:
            if not isinstance(query, str):
                continue
            query_lower = query.lower()
            if (query_lower not in book["title"].lower() and 
                query_lower not in book["author"].lower() and
                query_lower not in book.get("isbn", "").lower()):
                match = False
        
        if author and match:
            if not isinstance(author, str):
                match = False
            elif author.lower() not in book["author"].lower():
                match = False
        
        if title and match:
            if not isinstance(title, str):
                match = False
            elif title.lower() not in book["title"].lower():
                match = False
        
        if isbn and match:
            if not isinstance(isbn, str):
                match = False
            elif isbn != book.get("isbn", ""):
                match = False
        
        if match:
            results.append(book)
    
    return results


# ==================== Patron Status Management ====================

def get_patron_status_report(patron_id):
    """
    Get a comprehensive status report for a patron.
    
    Returns:
        dict: Patron status report
    """
    if not patron_id:
        return {
            "status": "error",
            "message": "Invalid patron ID"
        }
    
    # Use get_patron_borrowed_books to get borrowed books (for testing compatibility)
    borrowed_list = get_patron_borrowed_books(patron_id)
    
    # Process each borrowed book
    patron_books = []
    total_late_fees = 0.0
    
    for record in borrowed_list:
        book_id = record["book_id"]
        book = catalog.get(book_id)
        
        late_fee = 0.0
        if not record.get("returned", False):
            late_fee_data = calculate_late_fee_for_book(patron_id, book_id)
            if isinstance(late_fee_data, dict):
                late_fee = late_fee_data.get("fee_amount", 0.0)
            else:
                late_fee = late_fee_data if late_fee_data else 0.0
            total_late_fees += late_fee
        
        # Build book info from record (may already have title, author from mock)
        book_info = {
            "book_id": book_id,
            "title": record.get("title") or (book["title"] if book else "Unknown"),
            "author": record.get("author") or (book.get("author") if book else "Unknown"),
            "borrow_date": record.get("borrow_date").isoformat() if hasattr(record.get("borrow_date"), "isoformat") else record.get("borrow_date", ""),
            "due_date": record.get("due_date").isoformat() if hasattr(record.get("due_date"), "isoformat") else record.get("due_date", ""),
            "returned": record.get("returned", False),
            "return_date": record.get("return_date").isoformat() if record.get("return_date") and hasattr(record.get("return_date"), "isoformat") else record.get("return_date"),
            "late_fee": late_fee
        }
        patron_books.append(book_info)
    
    currently_borrowed_list = [b for b in patron_books if not b["returned"]]
    
    return {
        "status": "success",
        "patron_id": patron_id,
        "borrowed_books": patron_books,
        "borrow_history": patron_books,
        "total_books_borrowed": len(patron_books),
        "books_currently_borrowed": len(currently_borrowed_list),
        "current_borrowed": currently_borrowed_list,
        "total_late_fees": total_late_fees
    }


# ==================== Additional Helper Functions ====================

def get_book_by_isbn(isbn):
    """
    Get a book by its ISBN.
    
    Args:
        isbn: ISBN to search for
    
    Returns:
        dict: Book object if found, None otherwise
    """
    if not isbn:
        return None
    
    for book in catalog.values():
        if book.get("isbn") == isbn:
            return book
    
    return None


def get_patron_borrow_count(patron_id):
    """
    Get the count of books currently borrowed by a patron.
    
    Args:
        patron_id: Patron identifier
    
    Returns:
        int: Number of books currently borrowed
    """
    if not patron_id:
        return 0
    
    count = 0
    for record in borrowed_books.values():
        if record.get("patron_id") == patron_id and not record.get("returned", False):
            count += 1
    
    return count


# ==================== Database Insert Functions (for testing) ====================

def insert_book(book_data):
    """
    Insert a book directly into catalog (for testing).
    
    Args:
        book_data: Dictionary containing book information
    
    Returns:
        int: Book ID
    """
    global catalog_id_counter
    catalog_id_counter += 1
    book_id = catalog_id_counter
    
    book_data["book_id"] = book_id
    catalog[book_id] = book_data
    
    return book_id


def insert_borrow_record(borrow_data):
    """
    Insert a borrow record directly (for testing).
    
    Args:
        borrow_data: Dictionary containing borrow information
    
    Returns:
        str: Borrow key
    """
    patron_id = borrow_data.get("patron_id")
    book_id = borrow_data.get("book_id")
    
    if not patron_id or not book_id:
        return None
    
    borrow_key = f"{patron_id}_{book_id}"
    borrowed_books[borrow_key] = borrow_data
    
    return borrow_key

# -------------------- 测试 borrow_book_by_patron --------------------

def reset_globals():
    """每个测试前重置全局变量"""
    ls.catalog.clear()
    ls.borrowed_books.clear()
    ls.catalog_id_counter = 0

def test_borrow_book_success():
    # 直接插入书，获得 book_id
    book_id = ls.insert_book({
        "title": "Book",
        "author": "Author",
        "isbn": "1234567890",
        "total_copies": 5,
        "available_copies": 5
    })
    
    success, msg = ls.borrow_book_by_patron("123456", book_id)
    assert success
    assert "successfully" in msg
    borrow_key = f"123456_{book_id}"
    assert borrow_key in ls.borrowed_books